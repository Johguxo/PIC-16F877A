ADDLW k       // Add Literal and W            --->> W = w + k
ADDWF f,d     // Add W and f                  --->> d = W + f (d -->> W or F)
ANDLW k       // And Literal with W           --->> W = W AND k
ANDWF f,d     // And W with f                 --->> d = W AND f (d -->> W or F)
BCF f,b       // Bit Clear f                  --->> f(b) = 0
BSF f,b       // Bit Set f                    --->> f(b) = 1
BTFSC f,b     // Bit Test f, Skip if Clear    --->> f(b) = 0? If, Skip Function..
BTFSS f,b     // Bit Test f, Skip if Set      --->> f(b) = 1? If, Skip Function..
CALL k        // Subroutine Call              --->> Call to the Subroutine on direction k
CLRF f        // Clear f                      --->> f = 0
CLRW          // Clear W Register             --->> W = 0
CLRWDT        // Clear Watchdog Timer         --->> Watchdog timer = 0
COMF f,d      // Complement f                 --->> d = NOT f (d -->> W or F)
DECF f,d      // Decrement f                  --->> d = f - 1 (d -->> W or F)
DECFSZ f,d    // Decrementf, Skip if 0        --->> d = f - 1 = 0?? If, Skip Function..
GOTO k        // Go to address                --->> Jump to the direction k 
INCF f,d      // Increment f                  --->> d = f + 1 (d -->> W or F)
INCFSZ        // Increment f, Skip if 0       --->> d = f + 1 = 0?? If, Skip Function..
IORLW k       // Inclusive OR Literal with W  --->> W = W OR k
IORWF f,d     // Inclusive OR W with f        --->> d = f OR W (d -->> W or F)
MOVLW k       // Move literal to W            --->> W = k
MOVF f,d      // Move f                       --->> d = f (d -->> W or F)
MOVWF f       // Move W to f                  --->> f = W
NOP           //No Operation                  --->> No operation
OPTION
RET




